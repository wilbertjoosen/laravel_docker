import { ErrorStateMatcher } from '@angular/material/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { distinctUntilChanged, filter, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
import { FocusMonitor, A11yModule } from '@angular/cdk/a11y';
import { CommonModule } from '@angular/common';
import { MatFormFieldControl, MatInputBase, mixinErrorState, MatFormFieldModule, MatInputModule } from '@angular/material';
import { Component, ElementRef, HostBinding, Input, Optional, Self, ViewEncapsulation, NgModule } from '@angular/core';
import { FormControl, FormGroupDirective, NgControl, NgForm, ReactiveFormsModule } from '@angular/forms';
import { NgxWigModule } from 'ngx-wig';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable-next-line:typedef
/** @type {?} */
const _MatInputMixinBase = mixinErrorState(MatInputBase);
class MatNgxWigComponent extends _MatInputMixinBase {
    /**
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     * @param {?} _defaultErrorStateMatcher
     * @param {?} _focusMonitor
     * @param {?} _elRef
     */
    constructor(ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, _focusMonitor, _elRef) {
        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);
        this.ngControl = ngControl;
        this._focusMonitor = _focusMonitor;
        this._elRef = _elRef;
        this._uid = `lms-mat-ngx-wig-${MatNgxWigComponent.nextId++}`;
        this.describedBy = '';
        this.focused = false;
        this._required = false;
        this._disabled = false;
        this.shouldPlaceholderFloat = false;
        this.shouldLabelFloat = false;
        this.controlType = 'mat-ngx-wig';
        this._destroy$$ = new Subject();
        this.editorControl = new FormControl();
        this._onChange = () => { };
        this._onTouched = () => { };
        if (ngControl !== null) {
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value || this._uid;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.editorControl.value;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this.writeValue(newValue);
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} newPlaceholder
     * @return {?}
     */
    set placeholder(newPlaceholder) {
        this._placeholder = newPlaceholder;
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get empty() {
        return !!this.editorControl.value;
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} isRequired
     * @return {?}
     */
    set required(isRequired) {
        this._required = coerceBooleanProperty(isRequired);
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    set disabled(isDisabled) {
        this.setDisabledState(isDisabled);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._focusMonitor.monitor(this._elRef.nativeElement, true)
            .subscribe((origin) => {
            this.focused = !!origin;
            if (!this.focused) {
                this._onTouched();
            }
            this.stateChanges.next();
        });
        this.editorControl.valueChanges
            .pipe(distinctUntilChanged(), filter(() => this.editorControl.enabled), takeUntil(this._destroy$$))
            .subscribe((newValue) => {
            this._onChange(newValue);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.stateChanges.next();
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.describedBy = ids.join(' ');
    }
    /**
     * @param {?} _event
     * @return {?}
     */
    onContainerClick(_event) { }
    /**
     * @param {?} newValue
     * @return {?}
     */
    writeValue(newValue) {
        this.editorControl.setValue(newValue, { emitEvent: false });
        this.stateChanges.next();
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._disabled = coerceBooleanProperty(isDisabled);
        if (this._disabled) {
            this.editorControl.disable();
        }
        else {
            this.editorControl.enable();
        }
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy$$.next();
        this._destroy$$.complete();
        this.stateChanges.complete();
        this._focusMonitor.stopMonitoring(this._elRef.nativeElement);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
}
MatNgxWigComponent.nextId = 0;
MatNgxWigComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-ngx-wig',
                template: "<ngx-wig [formControl]=\"editorControl\"\n         [placeholder]=\"placeholder\">\n</ngx-wig>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: MatFormFieldControl,
                        useExisting: MatNgxWigComponent
                    }
                ],
                host: {
                    '[attr.id]': 'id',
                    class: 'component-wrapper'
                },
                styles: [".mat-form-field-type-mat-ngx-wig .mat-form-field-wrapper{padding:0!important}.mat-form-field-type-mat-ngx-wig .mat-form-field-infix{padding:0}.mat-form-field-type-mat-ngx-wig .mat-form-field-label-wrapper{display:none}.mat-form-field-type-mat-ngx-wig .mat-error{padding:8px 24px 24px;word-break:break-all}.mat-form-field-type-mat-ngx-wig .mat-hint{flex:1}.mat-form-field-type-mat-ngx-wig.mat-form-field{display:block!important;width:100%;line-height:inherit!important}.mat-form-field-type-mat-ngx-wig .mat-form-field-flex{display:flex!important;align-items:center!important;width:auto!important;line-height:24px;font-size:16px}.mat-form-field-type-mat-ngx-wig .mat-form-field-infix{border-top:none;width:100%!important}.mat-form-field-type-mat-ngx-wig .mat-form-field-infix:not(:first-child){margin-left:6px}.mat-form-field-type-mat-ngx-wig .mat-form-field-underline{position:relative!important;bottom:auto;margin-top:-1px}.mat-form-field-type-mat-ngx-wig .mat-form-field-underline .mat-form-field-ripple{top:-1px!important}.mat-form-field-type-mat-ngx-wig .mat-form-field-subscript-wrapper{position:static!important;font-size:12px;line-height:18px;margin-top:0}.mat-form-field-type-mat-ngx-wig .mat-form-field-hint-spacer{display:none}.mat-form-field-type-mat-ngx-wig.mat-form-field-disabled{cursor:not-allowed!important}", ".component-wrapper{display:block;width:100%}", ".nw-editor__res ol,.nw-editor__res ul{list-style-position:outside;margin-left:18px;padding:6px 0}.nw-editor__res ul{list-style-type:disc}.nw-editor__res ol{list-style-type:decimal}.nw-editor__res b,.nw-editor__res strong{font-weight:600}.nw-editor__res em,.nw-editor__res i{font-style:italic}.nw-editor__res a{color:#40a3de;text-decoration:underline}.nw-editor__res a:hover{text-decoration:none}.nw-toolbar{padding:0 21px!important;background:0 0!important;border-left:none!important;border-right:none!important;border-top:1px solid rgba(11,48,64,.2)!important;border-bottom:1px solid rgba(11,48,64,.2)!important;border-radius:0!important;color:#0b3040!important}.nw-toolbar__item{padding:3px;border-right:0!important}.nw-button{border:none!important;display:flex!important;align-items:center;justify-content:center;width:36px!important;height:36px!important;border-radius:2px!important;color:inherit;transition:opacity .2s}.nw-button:focus{background-color:rgba(11,48,64,.1)!important}.nw-button:active{background-color:rgba(11,48,64,.15)!important}.nw-button:before{font-size:22px!important}.nw-button--active{background-color:rgba(11,48,64,.1)!important}.nw-editor-container{border:none!important;border-radius:0!important}.nw-editor__src{padding:16px 24px!important}.nw-editor{display:block!important;padding:0!important;height:auto!important}.nw-editor__res{display:block!important;padding:16px 24px!important;font-size:16px;line-height:24px;height:400px!important;overflow:auto}.nw-editor__placeholder{padding:16px 24px!important}"]
            }] }
];
/** @nocollapse */
MatNgxWigComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] },
    { type: ErrorStateMatcher },
    { type: FocusMonitor },
    { type: ElementRef }
];
MatNgxWigComponent.propDecorators = {
    id: [{ type: Input }],
    describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
    placeholder: [{ type: Input }],
    required: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatNgxWigModule {
}
MatNgxWigModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    A11yModule,
                    CommonModule,
                    MatFormFieldModule,
                    MatInputModule,
                    NgxWigModule,
                    ReactiveFormsModule,
                ],
                declarations: [MatNgxWigComponent],
                exports: [MatNgxWigComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MatNgxWigComponent, MatNgxWigModule, _MatInputMixinBase as ɵa };

//# sourceMappingURL=mat-ngx-wig.js.map